import { 
    newID,
    isObject,
    isArray,
    _condi
} from "./libs/lib.js";
import { writeFileSync, readFileSync, readdirSync, mkdirSync } from "fs";

let dbPath: string = "";
let cacheData: any = null;
const _readCollection = (collection: string) => {
    try{
        cacheData = JSON.parse(readFileSync(`${dbPath}/${collection}.json`).toString())
    }catch(err: any){
        if(err.code === 'ENOENT'){
            writeFileSync(`${dbPath}/${collection}.json`, "{}");
            cacheData = {}
        }
    }
}
const _saveCollection = (collection: string) => {
    try{
        writeFileSync(`${dbPath}/${collection}.json`, JSON.stringify(cacheData));
        cacheData = null
    }catch(err: any){
        console.log(err)
    }
}
const _verify = (): boolean => {
    if(cacheData === null) return false
    if(!dbPath) return false
    return true
}
//Init
/**
 * Init your db path. required
 * @param path absolute path of your db folder
 */
export const dbInit = async(path: string)=>{
    try{
        if(!path) throw "No path specified, please specify absolute path to your db folder."
        dbPath = `${path}/db`;
        readdirSync(`${dbPath}`);
    }catch(err: any){
        if(err.code === 'ENOENT')
            mkdirSync(`${dbPath}`);
    }
}
//Insert
export const dbInsert = async(collection: string, data: any)=>{
    try{
        if(!collection) throw "Collection not specified";
        if(!data) throw "Data not specified";
        if(!(isObject(data)|| isArray(data))) throw "Data should be an Object"; 
        _readCollection(collection);
        if(!_verify()) throw "DB is not initialized properly";
        if(isObject(data)){
            const id = newID();
            cacheData[id] = {_id: id, ...data};
        }
        if(isArray(data)){
            data.forEach((d: any) => {
                const id = newID();
                cacheData[id] = {_id: id, ...d};
            })
        }
        _saveCollection(collection)
    }catch(err){console.log(err)}
}
//Find
/**
 * 
 * @param collection 
 * @param conditions Condition should be an Object: ex {_id: string } { _id: string[]}
 * @returns 
 */
export const dbFind = async(collection: string, conditions: any): Promise<any>=>{
    return new Promise(async(resolve, reject)=>{
        try{
            if(!collection) throw "Collection not specified";
            if(!(isObject(conditions))) throw "Data should be an Object";
            _readCollection(collection);
            if(!_verify()) throw "DB is not initialized properly";
            else{
                const results: any[] = [];
                if(Object.keys(conditions).length === 0){
                    for(let _id in cacheData) results.push(cacheData[_id]);
                    resolve(results)
                    return
                }
                for(let _id in cacheData){   
                    let valid = true;     
                    for(let field in conditions){
                        valid = _condi(field, cacheData[_id], conditions[field])
                        if(!valid) break
                    }
                    if(valid) results.push(cacheData[_id]);
                }
                resolve(results);
            }
        }catch(err){
            console.log(err)
            reject(err)
        }
    })
}
export const dbFindOne = async(collection: string, conditions: any): Promise<any>=>{
    return new Promise(async(resolve, reject)=>{
        try{
            if(!collection) throw "Collection not specified";
            if(!(isObject(conditions))) throw "Data should be an Object";
            _readCollection(collection);
            if(!_verify()) throw "DB is not initialized properly";
            else{
                let result: any = {};
                if(Object.keys(conditions).length === 0){
                    for(let _id in cacheData){ 
                        result = cacheData[_id];
                        break
                    }
                    resolve(result)
                    return
                }
                for(let _id in cacheData){   
                    let valid = true;     
                    for(let field in conditions){
                        valid = _condi(field, cacheData[_id], conditions[field])
                        if(!valid) break
                    }
                    if(valid){
                        result = cacheData[_id];
                        break
                    }
                }
                resolve(result);
            }
        }catch(err){
            console.log(err)
            reject(err)
        }
    })
}
//update
/**
 * 
 * @param collection 
 * @param conditions Should be an Object
 * @param data Should be an Object
 * @returns 
 */
export const dbUpdate = async(
    collection: string,
    conditions: any, 
    data: any, 
    newDoc: boolean = false
): Promise<any>=>{
    return new Promise(async(resolve, reject)=>{
        try{
            if(!collection) throw "Collection not specified";
            if(!(isObject(conditions))) throw "Data should be an Object";
            _readCollection(collection);
            if(!_verify()) throw "DB is not initialized properly";
            else{
                const stats = { modified: 0, new: 0 }
                if(Object.keys(conditions).length === 0){
                    for(let _id in cacheData){
                        for(let field in data){
                            cacheData[_id][field] = data[field];
                        }
                        stats.modified++;
                    }
                    _saveCollection(collection);
                    resolve(stats)
                    return
                }
                for(let _id in cacheData){   
                    let valid = true;     
                    for(let field in conditions){
                        valid = _condi(field, cacheData[_id], conditions[field])
                        if(!valid) break
                    }
                    if(valid){
                        for(let field in data){
                            cacheData[_id][field] = data[field];
                        }
                        stats.modified++;
                    }
                }
                if(newDoc){
                    const id = newID();
                    cacheData[id] = { _id: id };
                    for(let field in data)
                        cacheData[id][field] = data[field];
                    for(let condi in conditions){
                        if(isObject(condi)) continue
                        cacheData[id][condi] = conditions[condi];
                    }
                    stats.new ++;
                }
                _saveCollection(collection);
                resolve(stats)
            }
        }catch(err){
            console.log(err)
            reject(err)
        }
    })
}
//delete
export const dbDelete = async(collection: string, conditions: any): Promise<any>=>{
    return new Promise(async(resolve, reject)=>{
        try{
            if(!collection) throw "Collection not specified";
            if(!(isObject(conditions))) throw "Data should be an Object";
            _readCollection(collection);
            if(!_verify()) throw "DB is not initialized properly";
            else{
                const stats = { deleted: 0 }
                if(Object.keys(conditions).length === 0){
                    for(let _id in cacheData){ 
                        delete cacheData[_id];
                        stats.deleted ++;
                    }
                    _saveCollection(collection);
                    resolve(stats)
                    return
                }
                for(let _id in cacheData){   
                    let valid = true;     
                    for(let field in conditions){
                        valid = _condi(field, cacheData[_id], conditions[field])
                        if(!valid) break
                    }
                    if(valid) {
                        delete cacheData[_id];
                        stats.deleted ++;
                    }
                }
                _saveCollection(collection);
                resolve(stats);
            }
        }catch(err){
            console.log(err)
            reject(err)
        }
    })
}