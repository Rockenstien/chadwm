import { newID, isObject, isArray, _condi } from "./libs/lib.js";
import { writeFileSync, readFileSync, readdirSync, mkdirSync } from "fs";
let dbPath = "";
let cacheData = null;
const _readCollection = (collection) => {
    try {
        cacheData = JSON.parse(readFileSync(`${dbPath}/${collection}.json`).toString());
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            writeFileSync(`${dbPath}/${collection}.json`, "{}");
            cacheData = {};
        }
    }
};
const _saveCollection = (collection) => {
    try {
        writeFileSync(`${dbPath}/${collection}.json`, JSON.stringify(cacheData));
        cacheData = null;
    }
    catch (err) {
        console.log(err);
    }
};
const _verify = () => {
    if (cacheData === null)
        return false;
    if (!dbPath)
        return false;
    return true;
};
//Init
/**
 * Init your db path. required
 * @param path absolute path of your db folder
 */
export const dbInit = async (path) => {
    try {
        if (!path)
            throw "No path specified, please specify absolute path to your db folder.";
        dbPath = `${path}/db`;
        readdirSync(`${dbPath}`);
    }
    catch (err) {
        if (err.code === 'ENOENT')
            mkdirSync(`${dbPath}`);
    }
};
//Insert
export const dbInsert = async (collection, data) => {
    try {
        if (!collection)
            throw "Collection not specified";
        if (!data)
            throw "Data not specified";
        if (!(isObject(data) || isArray(data)))
            throw "Data should be an Object";
        _readCollection(collection);
        if (!_verify())
            throw "DB is not initialized properly";
        if (isObject(data)) {
            const id = newID();
            cacheData[id] = { _id: id, ...data };
        }
        if (isArray(data)) {
            data.forEach((d) => {
                const id = newID();
                cacheData[id] = { _id: id, ...d };
            });
        }
        _saveCollection(collection);
    }
    catch (err) {
        console.log(err);
    }
};
//Find
/**
 *
 * @param collection
 * @param conditions Condition should be an Object: ex {_id: string } { _id: string[]}
 * @returns
 */
export const dbFind = async (collection, conditions) => {
    return new Promise(async (resolve, reject) => {
        try {
            if (!collection)
                throw "Collection not specified";
            if (!(isObject(conditions)))
                throw "Data should be an Object";
            _readCollection(collection);
            if (!_verify())
                throw "DB is not initialized properly";
            else {
                const results = [];
                if (Object.keys(conditions).length === 0) {
                    for (let _id in cacheData)
                        results.push(cacheData[_id]);
                    resolve(results);
                    return;
                }
                for (let _id in cacheData) {
                    let valid = true;
                    for (let field in conditions) {
                        valid = _condi(field, cacheData[_id], conditions[field]);
                        if (!valid)
                            break;
                    }
                    if (valid)
                        results.push(cacheData[_id]);
                }
                resolve(results);
            }
        }
        catch (err) {
            console.log(err);
            reject(err);
        }
    });
};
export const dbFindOne = async (collection, conditions) => {
    return new Promise(async (resolve, reject) => {
        try {
            if (!collection)
                throw "Collection not specified";
            if (!(isObject(conditions)))
                throw "Data should be an Object";
            _readCollection(collection);
            if (!_verify())
                throw "DB is not initialized properly";
            else {
                let result = {};
                if (Object.keys(conditions).length === 0) {
                    for (let _id in cacheData) {
                        result = cacheData[_id];
                        break;
                    }
                    resolve(result);
                    return;
                }
                for (let _id in cacheData) {
                    let valid = true;
                    for (let field in conditions) {
                        valid = _condi(field, cacheData[_id], conditions[field]);
                        if (!valid)
                            break;
                    }
                    if (valid) {
                        result = cacheData[_id];
                        break;
                    }
                }
                resolve(result);
            }
        }
        catch (err) {
            console.log(err);
            reject(err);
        }
    });
};
//update
/**
 *
 * @param collection
 * @param conditions Should be an Object
 * @param data Should be an Object
 * @returns
 */
export const dbUpdate = async (collection, conditions, data, newDoc = false) => {
    return new Promise(async (resolve, reject) => {
        try {
            if (!collection)
                throw "Collection not specified";
            if (!(isObject(conditions)))
                throw "Data should be an Object";
            _readCollection(collection);
            if (!_verify())
                throw "DB is not initialized properly";
            else {
                const stats = { modified: 0, new: 0 };
                if (Object.keys(conditions).length === 0) {
                    for (let _id in cacheData) {
                        for (let field in data) {
                            cacheData[_id][field] = data[field];
                        }
                        stats.modified++;
                    }
                    _saveCollection(collection);
                    resolve(stats);
                    return;
                }
                for (let _id in cacheData) {
                    let valid = true;
                    for (let field in conditions) {
                        valid = _condi(field, cacheData[_id], conditions[field]);
                        if (!valid)
                            break;
                    }
                    if (valid) {
                        for (let field in data) {
                            cacheData[_id][field] = data[field];
                        }
                        stats.modified++;
                    }
                }
                if (newDoc) {
                    const id = newID();
                    cacheData[id] = { _id: id };
                    for (let field in data)
                        cacheData[id][field] = data[field];
                    for (let condi in conditions) {
                        if (isObject(condi))
                            continue;
                        cacheData[id][condi] = conditions[condi];
                    }
                    stats.new++;
                }
                _saveCollection(collection);
                resolve(stats);
            }
        }
        catch (err) {
            console.log(err);
            reject(err);
        }
    });
};
//delete
export const dbDelete = async (collection, conditions) => {
    return new Promise(async (resolve, reject) => {
        try {
            if (!collection)
                throw "Collection not specified";
            if (!(isObject(conditions)))
                throw "Data should be an Object";
            _readCollection(collection);
            if (!_verify())
                throw "DB is not initialized properly";
            else {
                const stats = { deleted: 0 };
                if (Object.keys(conditions).length === 0) {
                    for (let _id in cacheData) {
                        delete cacheData[_id];
                        stats.deleted++;
                    }
                    _saveCollection(collection);
                    resolve(stats);
                    return;
                }
                for (let _id in cacheData) {
                    let valid = true;
                    for (let field in conditions) {
                        valid = _condi(field, cacheData[_id], conditions[field]);
                        if (!valid)
                            break;
                    }
                    if (valid) {
                        delete cacheData[_id];
                        stats.deleted++;
                    }
                }
                _saveCollection(collection);
                resolve(stats);
            }
        }
        catch (err) {
            console.log(err);
            reject(err);
        }
    });
};
